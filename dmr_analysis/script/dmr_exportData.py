#This script is used to export data for MR or DMRs overlap with specific regions such as mutation blocks or enhancer regions
import os
import numpy as np
import pandas as pd
import glob
from .script_high.dmr_utility import submit_job_in_subprocess, divide_data2chunk
import argparse

def my_parser(parser):
   required =parser.add_argument_group('Required')
   required.add_argument('-in_MRfolder','--input_mr_data_folder', required=True, type=str, 
                         help='Input MR data folder, which is the output file folder of dmr_analysis_block')

   required.add_argument('-out_folder', '--output_file_folder', required=True, type=str, 
                         help='Output file folder for exported MR/DMR data ')

   required.add_argument('-in_format','--input_file_format', required=True, type=int, 
                         help=' Input file format, 0 for a bed format file where DMR/MR IDs are listed in the fourth column (e.g., chr18:mr0:mix:U), ' 
                              ' 1 for an exported file with 8 columns that generated by dds_analysis "check_block_gene_inTAD" '
                              ' where all DMRs and muntation blocks are assigned to a putative target gene and DMR/MR IDs are under column "new_mr_sites" ')

   required.add_argument('-in_file','--input_file', required=True,  type=str, 
                         help=' A file contains DMR/MR IDs that will be used to extract the raw and smoothed methlylation levels of '
                              ' DMRs/MRs listed in either a bed format file or an exported file from "dds_analysis check_block_gene_inTAD "')

   optional = parser.add_argument_group('Optional, has default values')
   optional.add_argument('-processes','--number_of_processes', default=5, type=int, metavar='',
                         help='Number of parallel processes that will be used to extract data, default = 5')

   optional.add_argument('-columnNumber','--input_file_bed_column', default=3, type=int, metavar='', 
                         help=' If input file is a bed format file, then this parameter will tell the column number of DMR/MR IDs.'
                              ' The default =3 which represents the 4th column because the index starts from 0')

   optional.add_argument('-columnName','--input_file_dds_column_name',default='new_mr_sites', type=str, metavar='',
                         help=' If input file is a file generated by "dds_analysis check_block_gene_inTAD", then this parameter will tell the column name of DMR/MRs IDSs.'
                              ' The default = new_mr_sites')

   optional.add_argument('-wtStr','--wildType_fileString',
                         default='gcb',
                         type=str,
                         metavar='',
                         help=' A file name of the wild type condition file which shall start with these characters. For example, if a file name starts with "gcb_meht1_*"  is a wild type/control sample'
                              ', then --wildType_fileString is "gcb", which is the default setting in the program. ')

   optional.add_argument('-dotOrUnderscore','--column_splitBy_dotOrUnderscore', default=0, type=int, metavar='', 
                          help= '0 for dot . split column label, 1 for underscore _ split column label in file --in_data_file , default=0 dot split column labels')

   return parser

def cmd4extract_mr_data4chrom(mr_data_folder,list_mr_ids,tmp_chr,tmp_out_folder, wt_string, dotOrUnderscore ):
  '''make command line for extracting mr data'''
  cmd2=[]
  tmp_id=list_mr_ids
  tmp_mr_id=','.join(tmp_id)
  dmr_out_chrom_folder= os.path.join(mr_data_folder,tmp_chr)
  print(dmr_out_chrom_folder)
  dmr_out_chrom2mr_block_file=os.path.basename(glob.glob(os.path.join(dmr_out_chrom_folder,'chr*_data.txt.gz'))[0])
  #in older version it is chr*all but in the new version it is chr*all_mr_data.tsv
  dmr_out_chrom2mr_file=os.path.basename(glob.glob(os.path.join(dmr_out_chrom_folder,'plots','chr*_all_mr_data.tsv'))[0])
  cmd1='dmr_analysis dmr_selected4plot -inDMR '+ dmr_out_chrom2mr_file + \
               ' -inData ' + dmr_out_chrom2mr_block_file + \
               ' -inFolder ' + dmr_out_chrom_folder +  \
               ' -inNdChk ' +  tmp_mr_id  + \
               ' -wtStr ' + wt_string +  \
               ' -inOutFd ' + tmp_out_folder + \
               ' -dotOrUnderscore ' + str(dotOrUnderscore) + \
               ' -inIsExt ' +  str(1)
  mr_ids=tmp_mr_id.split(',')
  cmd2=[]
  #this doesnot need now because the export file is already in gzip format
  #for mi in mr_ids:
  #   #cmd2.append('gzip -f ' + os.path.join(tmp_out_folder+tmp_chr,tmp_chr+'*'+mi+'.pdf'))
  #   cmd2.append('gzip -f ' + os.path.join(tmp_out_folder,tmp_chr,'data',tmp_chr+'*'+mi+'.dat'))
  #   cmd2.append('gzip -f ' + os.path.join(tmp_out_folder,tmp_chr,'data',tmp_chr+'*'+mi+'_raw.dat'))
  return cmd1,cmd2

def get_mr_in_blocks(mr_df):
 '''input dataframe of combined dmr_analysis result, then extract mr_id that locates in blocks, and the corresponding gene ->block information'''
 record_mr_in_blocks=[]
 record_gene2mr={}
 for index,rows in mr_df.iterrows():
   tmp_gene_type=rows.gene_type.split('~')
   tmp_mr_sites=rows.new_mr_sites.split('~')
   tmp_block_id=rows.block_id.split('~')
   if not pd.isnull(rows.enhancers) :
      tmp_enhancers=rows.enhancers.split('~')
   else:
      tmp_enhancers=['nan']
   np_genetype=np.array(tmp_gene_type)
   np_enhancers=np.array(tmp_enhancers)
   np_mr=np.array(tmp_mr_sites)
   np_block_id=np.array(tmp_block_id)
   mr_idx=[i for i, item in enumerate(np_mr) if 'mr' in item]
   #print(np_mr[mr_idx], np_enhancers[mr_idx] , np_genetype[mr_idx],np_block_id[mr_idx] )
   record_gene2mr[rows.gene_name]=(np_mr[mr_idx], np_enhancers[mr_idx] , np_genetype[mr_idx] , np_block_id[mr_idx])
   tmp_mr=list(np_mr[mr_idx])
   tmp_mr2=[]
   for i in tmp_mr :
      tmp_mr2 += [si.strip() for si in i.split(',')]
   #record_mr_in_blocks += list(np_mr[mr_idx])
   record_mr_in_blocks += tmp_mr2
 #there is all DMRs in mutation blocks
 out_mr_in_blocks=list(set(record_mr_in_blocks))
 return record_gene2mr, out_mr_in_blocks

def extract_mr_data_in_parallel(mr_ids,num_of_processes,mr_data_folder,tmp_out_folder,wt_string,dotOrUnderscore):
  '''input mr ids in dataframe then run the code'''
  uniq_chr=mr_ids[0].unique()
  record_mr_ids={}
  #parallel within each chromosome
  for ci in uniq_chr:
      list_of_ids, block_chunks, record_cmd1, record_cmd2=[],[],[],[]
      record_mr_ids[ci]= mr_ids[mr_ids[0]==ci][1].to_list()
      print(len(record_mr_ids[ci]), ci)
      list_of_ids=record_mr_ids[ci]
      block_chunks, num_of_processes= divide_data2chunk(num_of_processes, list_of_ids)
      for bi in block_chunks:
        tmp_cmd1,tmp_cmd2=cmd4extract_mr_data4chrom(mr_data_folder,bi,ci,tmp_out_folder,wt_string,dotOrUnderscore)
        record_cmd1.append(tmp_cmd1)
        #record_cmd2.extend(tmp_cmd2)
      #tmp_cmd2  does not need now because the export file is already in gzip format
      submit_job_in_subprocess(record_cmd1)
      #submit_job_in_subprocess(record_cmd2)
  return

def run(args):
 #required
 mr_data_folder=args.input_mr_data_folder
 is_bed_or_dds_file=args.input_file_format
 tmp_out_folder=args.output_file_folder
 num_of_processes=args.number_of_processes
 in_file_name=args.input_file
 dotOrUnderscore=args.column_splitBy_dotOrUnderscore

 #optional
 bed_column_number_of_mrID=args.input_file_bed_column
 dds_column_label_of_mrID=args.input_file_dds_column_name
 wt_string=args.wildType_fileString 

 if is_bed_or_dds_file==0 :
   print('Input file in bed format:  chr; start; end; chr:mrID:chrStart,..,chrEnd:mrType:D/U; p-value ')
   #this is a bed format file: chr; start; end; chr:mrID:chrStart,..,chrEnd:mrType:D/U; p-value
   out_file2mr_not_in_enhancer_tss= in_file_name #'test_mr_not_enhancer_tss.bed'
   mr_df=pd.read_csv(out_file2mr_not_in_enhancer_tss,sep='\t',header=None)

   mr_ids = mr_df.iloc[:, bed_column_number_of_mrID].str.split(':',expand=True)
   extract_mr_data_in_parallel(mr_ids,num_of_processes,mr_data_folder,tmp_out_folder, wt_string, dotOrUnderscore)

 if is_bed_or_dds_file==1 :
   print('Input file in dds_analÃ½sis export file format: dds_analysis check_block_gene_inTAD-> gene_name; gene_type; block_id; new_mr_sites; patients; isTAD; enhancers; patient_id ')
   in_gene_mr_file=in_file_name #'test_mr_in_block_regions.tsv'

   in_df=pd.read_csv(in_gene_mr_file,sep='\t')
   #count how many genes have MRs
   mr_df=in_df[in_df[dds_column_label_of_mrID].apply(lambda x: str(x).find(':mr')>=0)].copy()
   mr_df.reset_index(inplace=True)
   #check how many mr located in TSS or 5distance regions
   record_gene2mr,out_mr_in_blocks= get_mr_in_blocks(mr_df)
   mr_df=pd.DataFrame(data=out_mr_in_blocks)
   mr_ids=mr_df[0].str.split(':',expand=True)
   extract_mr_data_in_parallel(mr_ids,num_of_processes,mr_data_folder,tmp_out_folder, wt_string, dotOrUnderscore)
 return

if __name__ == '__main__':
  args= my_parser(argparse.ArgumentParser('python dmr_exportData.py')).parse_args()
  run(args)
  
